//#include <iostream>
//using namespace std;
//
////가상함수(virtual function)은 자식 클래스에서 재정의할 것으로 기대가되는 멤버함수
//
////1. 오버라이딩에 대한 개념을 확인
////2. 가상 함수 키워드를 사용해야 하는 이유
//
////해당 개념은 클래스를 동적으로 할당하는 상황에서 발생
//
//class A
//{
//public:
//	virtual void Function() { cout << "A 안에 있는 함수" << endl; };
//};
//
//class B : public A
//{
//	//Overriding :재정의 작업을 의미. 클래스의 상속관계에서 물려받은 함수를 자식 클래스에서 구현하는 작업 의미.
//	//Overloading:함수를 구현할 때 도입부에서 매개변수의 개수, 순서, 종류를 다르게 하여 같은 이름이 함수를 다른 기능을 가진 함수로 만들어 주는 기법
//public:
//	//오버라이딩한 함수는 따로 virtual을 붙이지 않음
//	void Function() { cout << "B에서 재정의를 진행. 오버라이딩" << endl; };
//};
//
//int main()
//{
//	A a;//본인의 형태로 개체 생성
//	B b;
//	a.Function();
//	b.Function();
//
//	A* a2 = new A();//클래스를 동적 할당으로 생성
//	B* b2 = new B();
//
//	a2->Function();
//	b2->Function();
//
//	A* a3 = new B();//부모를 자식의 형태로 생성을 진행
//	a3->Function();//자식의 형태가 아닌 부모의 형태가 출력.
//	//ㅇㅣ유: 함수의 호출 시 컴파일 과정에서 고정되었는 메모리 주소를 불러오게 됨
//	//A클래스가 생성되면서 안에 있던 함수 Function의 위치는 컴파일 과정에서 고정되어 있기 때문에 B의
//	//형태로 생성을 진행해도 A클래스의  Funtion위치의 값을 호출. (정적 바인딩 static binding)
//
//	//해결방법: 부모 클래스의 함수를 virtual 키워드를 붙여서 가상 함수로 설정
//	//해당 키워드가 붙은 함수는 실행 과정에서 함수를 참조를 통해 호줄하게 되어 만들어진 함수를 호출.(동적 바인딩 dynamic binding)
//
//	//자식이 부모의 형태로 생성되는 것은 불가능
//
//	delete a2, b2, a3;
//
//	return 0;
//}