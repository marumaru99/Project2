//#include <iostream>
//using namespace std;
//
////기존의 작업을 통해 클래스의 필드 값을 메인에서 초기화 하는 식으로 진행
////작업 시간이 오래 걸림
////클래스 생성 시 호출되는 함수 생성자 존재. 이를 통해 필드 값 초기화를 더 쉽게 진행.
//
//
//class ITEM
//{
//public:
//	string name;
//	string dec;
//	ITEM(){} //아이템에 대한 기본 생성자
//	//기본 생성자는 아래의 코드처럼 생성자가 새롭게 작성되었을 경우 아이템에 대한 선언을 할 수 없으므로 추가함.
//	ITEM(string n, string d);
//	//생성자 오버로딩 : 생성자의 이름이 같아도 매개변수의 개수, 순서가 다를 경우 프로그램에서 다른 값으로 인식.
//	//생성자는 클래스와 이름이 동일. ()안에 매개변수 추가하는 식으로 필드 초기화할 때 사용
//	
//	void ItemInfo();
//
//};
//
//int main()
//{
//	ITEM item01;
//	//생성자는 클래스를 생성할 때 호출되는 클래스와 이름이 같으면서 별도의 타입은 없는 메소드.
//	//생성자가 클래스 내에 정의되었을 경우 그 형태를 따라가야함.
//	//위의 코드를 아래와 같이 다시 작성
//
//	ITEM item02("백산수", "살아있는 화산 암반수"); //ITEM의 생성자 형태대로 생성을 진행
//	item01.ItemInfo();
//	item02.ItemInfo();
//
//	//본인이 위에있는 선언 코드도 사용하고 싶은 경우 ITEM 생성자에 대한 작업을 추가 진행(생성자 오버로딩 기법 Constructor Overloading)
//
//	return 0;
//}
//
////리팩터링을 통해 클래스의 메소드를 아래에서 재정의하여 클래스 코드 전체의 가독성을 높임
//ITEM::ITEM(string n, string d)
//{
//	name = n;//생성자에 받은 필드 값으로 초기화되는 코드 추가
//	dec = d;
//}
//
//void ITEM::ItemInfo()
//{
//	cout << "아이템의 이름: " << name << endl;
//	cout << dec << endl;
//}
